package com.pfizer.equip.searchservice.indexer;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.util.List;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.pfizer.elasticsearch.api.client.ElasticSearchClient;
import com.pfizer.equip.filedata.modeshape.NodeDataFetcher;
import com.pfizer.equip.searchable.dto.CommentData;
import com.pfizer.equip.searchable.dto.SearchableData;
import com.pfizer.equip.searchable.elasticsearch.CommentDataFetcher;
import com.pfizer.equip.searchable.elasticsearch.SearchableDataIndexer;
import com.pfizer.equip.searchable.elasticsearch.SearchableFetcher;
import com.pfizer.equip.searchservice.AppPropertyNames;
import com.pfizer.modeshape.api.client.ModeshapeClient;

/**
 * Indexer does the work of updating the search index when
 * new Searchable nodes are added or existing Searchable nodes 
 * are updated.
 * 
 * @author HeinemanWP
 *
 */
public class Indexer {
	private static Logger log = LoggerFactory.getLogger(Indexer.class);
	private static final String LAST_UPDATE_TIME_PROPERTY = "lastUpdateTime";
	private static final String LAST_UPDATE_TIME_PROPERTY_DEFAULT = "-1";
	private static final int UPDATE_COUNT = 100;
	private Properties appProperties;
	private String updateFilename;
	private Properties updateProperties = new Properties();
	private ModeshapeClient msc;
	private NodeDataFetcher ndf;
	private ElasticSearchClient esc;
	private SearchableFetcher sf;
	private CommentDataFetcher cdf;
	private SearchableDataIndexer sdi;
	
	public Indexer() {}
	
	public Indexer(Properties appProperties) {
		this.appProperties = appProperties;
		updateFilename = appProperties.getProperty(
				AppPropertyNames.INDEX_UPDATE_FILE, AppPropertyNames.INDEX_UPDATE_FILE_DEFAULT);
	}
	
	public void index() throws IndexerException {
		if (appProperties == null) {
			return;
		}
		try {
			if (msc == null) {
				log.info(String.format("appProperties.getProperty(AppPropertyNames.MODESHAPE_SERVER): %s", appProperties.getProperty(AppPropertyNames.MODESHAPE_SERVER)));
				msc = new ModeshapeClient(
						appProperties.getProperty(
								AppPropertyNames.MODESHAPE_SERVER),
						appProperties.getProperty(
								AppPropertyNames.MODESHAPE_USERNAME),
						appProperties.getProperty(
								AppPropertyNames.MODESHAPE_PASSWORD));
				ndf = new NodeDataFetcher(msc);
			}
			if (esc == null) {
				log.info(String.format("appProperties.getProperty(AppPropertyNames.ELASTICSEARCH_SERVER): %s", appProperties.getProperty(AppPropertyNames.ELASTICSEARCH_SERVER)));
				esc = new ElasticSearchClient(
						appProperties.getProperty(
								AppPropertyNames.ELASTICSEARCH_SERVER),
						appProperties.getProperty(
								AppPropertyNames.ELASTICSEARCH_USERNAME),
						appProperties.getProperty(
								AppPropertyNames.ELASTICSEARCH_PASSWORD));
				sf = new SearchableFetcher(esc);
				cdf = new CommentDataFetcher(esc);
				sdi = new SearchableDataIndexer(esc);
			}

			// Get last update time from file
			long lastUpdateTime = getLastUpdateTime();
			
			// Get new and updated searchables
			List<String> updatedIds = sf.getIdsUpdatedSince(Instant.ofEpochMilli(lastUpdateTime), UPDATE_COUNT);
			// For each new and update searchable
			for (String updatedId : updatedIds) {
				lastUpdateTime = updateIndex(lastUpdateTime, updatedId);
			}
			// Write new update time to file
			setLastUpdateTime(lastUpdateTime);
		} catch(Exception ex) {
			throw new IndexerException("", ex);
		}
	}

	private long updateIndex(long lastUpdateTime, String updatedId) {
		try {
			// Update or insert index
			String logMsg = String.format("P: %s", updatedId); 
			log.info(logMsg);
			SearchableData parentNodeData = ndf.fetchNode(updatedId);
			SearchableData contentData = ndf.fetchContentNode(updatedId);
			boolean noContentData = contentData == null;
			if (noContentData) {
				contentData = parentNodeData;
			}
			List<CommentData> comments = cdf.getDataByPath(parentNodeData.getJcrPath(), 0, 1000);
			String contentId;
			if (noContentData) {
				contentData.setEquipCommentFromCommentData(comments);
				contentId = sdi.insertContentNode(updatedId, contentData);
			} else {
				contentId = contentData.getJcrUuid();
				SearchableData searchableData = ndf.fetchSearchableData(contentId, parentNodeData);
				searchableData.setEquipCommentFromCommentData(comments);
				sdi.updateContentNode(contentId, searchableData);
			}
			if ((contentData.getJcrMimeType() != null)
					&& contentData.getJcrMimeType().equalsIgnoreCase("text/csv")) {
				ndf.updateNodeMimeType(contentData.getFileId(), "text/csv");
			}
			lastUpdateTime = updateLastUpdateTime(lastUpdateTime, parentNodeData);
			logMsg = String.format("C: %s", contentId);
			log.info(logMsg);
		} catch(Exception ex) {
			log.error("", ex);
		}
		return lastUpdateTime;
	}

	private long updateLastUpdateTime(long lastUpdateTime, SearchableData parentNodeData) {
		Instant parentCreated = parentNodeData.getEquipCreated();
		Instant parentModified = parentNodeData.getEquipModified();
		Instant parentUpdated = parentCreated;
		if (parentModified != null) {
			parentUpdated = parentModified;
		}
		if (parentUpdated.toEpochMilli() > lastUpdateTime) {
			lastUpdateTime = parentUpdated.toEpochMilli();
		}
		return lastUpdateTime;
	}
	
	private long getLastUpdateTime() throws IOException {
		try(FileReader fr = new FileReader(updateFilename) ){
			updateProperties.load(fr);
			long returnValue = Long.parseLong(
					updateProperties.getProperty(LAST_UPDATE_TIME_PROPERTY, LAST_UPDATE_TIME_PROPERTY_DEFAULT));
			if (returnValue < 0) {
				returnValue = Instant.now().toEpochMilli();
			}
			return returnValue;
		} catch (IOException ex) {
			log.error(String.format("Failed to load update properties file %s", 
					updateFilename), ex);
			throw ex;
		}
	}
	
	private void setLastUpdateTime(long lastUpdateTime) {
		try(FileWriter fw = new FileWriter(updateFilename)) {
			updateProperties.put(LAST_UPDATE_TIME_PROPERTY, Long.toString(lastUpdateTime));
			Instant instant = Instant.ofEpochMilli(lastUpdateTime);
			updateProperties.store(fw, 
					String.format("%s\n", instant.toString()));
		} catch (IOException ex) {
			log.error(String.format("Failed to save update properties file %s", 
					updateFilename), ex);
		}
	}

	public void setProperties(Properties appProperties) {
		msc = null;
		esc = null;
		this.appProperties = appProperties;
		updateFilename = appProperties.getProperty(
				AppPropertyNames.INDEX_UPDATE_FILE, AppPropertyNames.INDEX_UPDATE_FILE_DEFAULT);
	}
	
}
