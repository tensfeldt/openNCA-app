package com.pfizer.equip.searchservice.search;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Manages thread that handles searches.
 * 
 * @author HeinemanWP
 *
 */
public class Searches {
	private static final int EXPIRY_SLEEP_TIME = 5000;
	private final Map<String, BaseSearch> searchesMap = new ConcurrentHashMap<>();
	private ExecutorService expiryService;
	private boolean running = false;
	
	public Searches() {
		expiryService = Executors.newSingleThreadExecutor();
	}
	
	public void addSearch(String id, Search search) {
		searchesMap.put(id, search);
		if (!running) {
			start();
		}
	}

	public BaseSearch getSearch(String id) {
		return searchesMap.get(id);
	}


	public void start() {
		if (!running) {
			expiryService.execute(new Runnable() {
	
				@Override
				public void run() {
					while(true) {
						try {
							process();
						} catch (InterruptedException e) {
							// Do nothing.
						}
					}
				}});
			running = true;
		}
	}
	
	public void stop() {
		if (!expiryService.isShutdown()) {
			expiryService.shutdown();
		}
		running = false;
	}

	
	private void process() throws InterruptedException {
		List<String> toRemove = new ArrayList<>();
		for (Map.Entry<String, BaseSearch> entry : searchesMap.entrySet()) {
			String searchId = entry.getKey();
			BaseSearch search = entry.getValue();
			if (search.isExpired()) {
				toRemove.add(searchId);
			}
		}
		for (String searchId: toRemove) {
			searchesMap.remove(searchId);
		}
		Thread.sleep(EXPIRY_SLEEP_TIME);
	}
	
}
