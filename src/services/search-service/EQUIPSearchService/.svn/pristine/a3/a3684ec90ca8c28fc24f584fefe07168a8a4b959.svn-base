package com.pfizer.equip.searchable.elasticsearch;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.pfizer.elasticsearch.api.client.ElasticSearchClient;
import com.pfizer.elasticsearch.api.client.ElasticSearchClientException;

/**
 * Retrieves data for equip:searchable nodes from elasticsearch.
 * 
 * @author HeinemanWP
 *
 */
public class SearchableFetcher {
	private static String INDEX = "esvalndx-nca";
	private static String TYPE = "nca";
	private static String ID_QUERY = "{ \"_source\":[\"_id\"], \"query\" : {\"match_all\": {}}, \"from\" : %d, \"size\" : 1 }";
	// private static String ID_REGEX = "(\\\"_id\\\":\\\")([a-f 0-9 -]+)";
	private static String ID_REGEX = "([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)";	
	private static Pattern ID_PATTERN = Pattern.compile(ID_REGEX, Pattern.CASE_INSENSITIVE);
	private static String COUNT_REGEX = "^(.*\"hits\":.*\\{\"total\":)([0-9]*)(.*)";
	private static Pattern COUNT_PATTERN = Pattern.compile(COUNT_REGEX, Pattern.CASE_INSENSITIVE);
	private static String UPDATE_QUERY_OLD = "{ \"_source\":[\"_id\"], " + 
			"  \"query\" :  { \"bool\" : { \"must\" : [" + 
			"                                    { \"bool\" : { \"should\" : [{\"query_string\":{\"default_field\" : \"jcr:created\", \"query\" : \">%d\"}}," + 
			"						                                     {\"query_string\":{\"default_field\" : \"jcr:lastModified\", \"query\" : \">%d\"}}]}}]}}," + 
			"  \"sort\" : [{\"jcr:lastModified\" : {\"order\" : \"asc\"}}, {\"jcr:created\" : {\"order\" : \"asc\"}}],	" + 
			"  \"from\" : %d, \"size\" : %d }";

	private static String UPDATE_QUERY = "{ \"_source\":[\"_id\"], " + 
			"  \"query\" :  { \"bool\" : { \"must\" : [" + 
			"                                    { \"bool\" : { \"should\" : [{\"query_string\":{\"default_field\" : \"jcr:created\", \"query\" : \">%d\"}}," + 
			"						                                     {\"query_string\":{\"default_field\" : \"jcr:lastModified\", \"query\" : \">%d\"}}]}}]}}," + 
			"  \"sort\" : [{\"jcr:lastModified\" : {\"order\" : \"asc\"}}, {\"jcr:created\" : {\"order\" : \"asc\"}}],	" + 
			"  \"from\" : %d, \"size\" : %d }";
	private static String STUDY_QUERY = "{ \"_source\": [\"_id\"], "
			+ "\"query\" : { \"match_phrase\": {\"equip:studyId\": \"%s\"} }, "
			+ "\"from\" : 0, \"size\" : 5000 }";

	private ElasticSearchClient esc;

	public SearchableFetcher(ElasticSearchClient esc) {
		this.esc = esc;
	}
	
	public int getCount() throws ElasticSearchClientException {
		int returnValue = 0;
		String result = esc.searchIndex(INDEX, TYPE, String.format(ID_QUERY, 0));
		Matcher m = COUNT_PATTERN.matcher(result);
		if (m.matches()) {
			returnValue = Integer.parseInt(m.group(2));
		}
		return returnValue;
	}
	
	public String getId(int offset) throws ElasticSearchClientException {
		return getId(esc.searchIndex(INDEX, TYPE, String.format(ID_QUERY, offset)));
	}
	
	public List<String> getIdsUpdatedSince(Instant lastUpdate, int count) throws ElasticSearchClientException {
		long lastUpdateMillis = lastUpdate.toEpochMilli();
		esc.refreshIndex(INDEX);
		return getIds(esc.searchIndex(INDEX, TYPE, String.format(UPDATE_QUERY, lastUpdateMillis, lastUpdateMillis, 0, count)));
	}
	
	public List<String> getIdsInStudy(String study) throws ElasticSearchClientException {
		esc.refreshIndex(INDEX);
		return getIds(esc.searchIndex(INDEX, TYPE, String.format(STUDY_QUERY, study)));
	}

	private List<String> getIds(String nodeData) {
		List<String> returnValue = new ArrayList<>();
		Matcher m = ID_PATTERN.matcher(nodeData);
		while (m.find()) {
			String id = m.group();
			if (id.startsWith("\"")) {
				id = id.substring(1);
			}
			returnValue.add(id);
		}
		return returnValue;
	}
	private String getId(String nodeData) {
		Matcher m = ID_PATTERN.matcher(nodeData);
		String returnValue = null;
		if (m.find()) {
			returnValue = m.group();
			if (returnValue.startsWith("\"")) {
				returnValue = returnValue.substring(1);
			}
		}
		return returnValue;
	}

}
